'From Pharo10.0.0 of 15 March 2023 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)] on 22 February 2024 at 12:11:45.097 pm'!Object subclass: #Boggle	instanceVariableNames: ''	classVariableNames: ''	package: 'CPS506'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Boggle class	instanceVariableNames: 'path visited N powers board word adj'!!Boggle class methodsFor: 'as yet unclassified' stamp: 'BrandonTon 2/22/2024 11:59'!search: newBoard for: words 	| pos ans i power adjPoints |	"Transcript clear."	board := newBoard.	N := board size.	adjPoints := #( (-1 -1) (-1 0) (-1 1) (0 -1) (0 1) (1 -1) (1 0) (1 1) ).		adj := (1 to: 273) collect: [ :index |		(1 to: 26) collect: [ :_ |			OrderedCollection new.		].	].	1 to: N do: [ :y |		1 to: N do: [ :x |			adjPoints do: [ :point |				| nX nY |				nX := x + (point second).				nY := y + (point first).				((nX > 0 and: [ nX <= N ]) and: [ (nY > 0 and: [ nY <= N ]) ]) ifTrue: [					| targetIndex |					targetIndex := ((board at: nY) at: nX) asciiValue - $a asciiValue + 1.					((adj at: y * N + x) at: targetIndex) add: (nY * N + nX).				].			].		].	].	powers := OrderedCollection new.	power := 1.	1 to: 273 do: [ :j |		powers add: power.		power := power bitShift: 1.	].	pos := Array new: 26.	0 to: 25 do: [ :index |		| positions |		positions := OrderedCollection new.		1 to: N do: [ :y |			1 to: N do: [ :x |				(((board at: y) at: x) asciiValue = (index + ($a asciiValue)))					ifTrue: [ positions add: (y@x) ].			].		].		pos at: (index + 1) put: positions.	].	ans := Dictionary new.	words do: [ :newWord |		| X Y skip |		skip := false.     		newWord do: [ :char |			(1 <= (char asciiValue - $a asciiValue + 1) and: (char asciiValue - $a asciiValue + 1) <= 26) ifFalse: [skip := true].		].		skip ifFalse: [			word := newWord.			(pos at: (word first asciiValue - $a asciiValue + 1)) do: [ :position |				Y := (position x).				X := (position y).				visited := powers at: (Y * N + X).				path := (OrderedCollection with: (Y@X)).				i := 2.				(self dfs: X y: Y i: i) ifNotNil: [ :solution |					ans at: word put: solution.				].			].		].	].	^ ans.! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'BrandonTon 2/22/2024 12:01'!dfs: X y: Y i: i	| wordLetterAsc nx ny ans key |	"Transcript show: word; cr."		(i - 1 = (word size)) ifTrue: [ ^ path copy asArray ].	wordLetterAsc := (word at: i) asciiValue - $a asciiValue + 1.	"(1 <= wordLetterAsc and: wordLetterAsc <= 26) ifFalse: [^ self dfs: X y: Y i: (i + 1)]."		((adj at: (Y * N + X)) at: wordLetterAsc) do: [ :eachPos |		ny := (eachPos - 1) // N.		nx := (eachPos - 1) \\ N + 1.		key := powers at: eachPos.    		((visited bitAnd: key) = 0 and: [((board at: ny) at: nx) = (word at: i)]) ifTrue: [			"Transcript show: ny; show: nx; show: (word at: i); cr.			Transcript show: (visited printStringBase: 2); cr."			visited := visited bitOr: key.			path add: (ny@nx).			"Transcript show: path ; cr."									ans := self dfs: nx y: ny i: (i + 1).			ans ifNotNil: [ ^ ans ].			visited := visited bitXor: key.			path removeLast.		].	].	^ nil! !